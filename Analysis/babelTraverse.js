const traverse = require("@babel/traverse").default;
const fs = require("fs");
const path = require("path");
const ast = require("../../ast.json"); // ast.json is generated by acornTest.js
const astDir = "./Asts";

const lineTotal = new Set();
const nodeTypes = new Set();
const useState = new Set();
const reactComponentsPath = new Set();
const reactComponentsList = [];
const reactComponents = [];

const isReturningJSX = (path) => {
  let hasJSX = false;
  path.traverse({
    ReturnStatement(returnPath) {
      if (
        returnPath.node.argument &&
        returnPath.node.argument.type === "JSXElement"
      ) {
        try {
          const parentNode = path.findParent((path) =>
            path.isVariableDeclaration()
          );
          if (parentNode.node.declarations[0].id.name === "WorkoutName") {
            console.log("hereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee");
            console.log("Workout");
            console.log(returnPath.node.argument.type);
            console.log("end");
          }
        } catch (e) {}
        hasJSX = true;
      }
    },
  });
  return hasJSX;
};
const getComponentsLOC = (path) => {
  let componetLOC = path.node.loc.end.line - path.node.loc.start.line + 1;
  return componetLOC;
};

const getComponentsProps = (path) => {
  const props = path.node.params[0];
  if (props && props.type === "ObjectPattern") {
    const properties = props.properties.map((prop) => prop.key.name);
    return properties;
  }
};
const traverseAll = () => {
  return new Promise((resolve, reject) => {
    fs.readdir(astDir, (err, files) => {
      if (err) {
        console.error("file read error:", err);
        reject(err);
        return;
      }

      Promise.all(
        files.map((file) => {
          if (file.endsWith(".json")) {
            const filePath = path.join(astDir, file);

            return new Promise((resolve, reject) => {
              fs.readFile(filePath, "utf-8", (err, json) => {
                if (err) {
                  console.error("Error reading file:", err);
                  reject(err);
                  return;
                }
                const ast = JSON.parse(json);
                traverseFile(ast);
                resolve();
              });
            });
          } else {
            return Promise.resolve();
          }
        })
      ).then(resolve);
    });
  });
};
const traverseFile = (ast) => {
  traverse(ast, {
    enter(path) {
      if (path.node.loc) {
        lineTotal.add(path.node.loc.start.line);
        nodeTypes.add(path.node.type);
      }
    },
    VariableDeclaration(path) {
      // console.log(path.node.type);
    },
    FunctionDeclaration(path) {
      // console.log(path.node.type);

      if (isReturningJSX(path)) {
        if (path.node.id && path.node.id.name) {
          //   console.log("JSX :" + path.node.id.name);
          reactComponentsPath.add(path);
          reactComponentsList.push(path.node.id.name);
        }
      }
    },
    ClassDeclaration(path) {
      //   //   console.log(path.node.type);
      //   let ReactComponent = false;
      //   path.traverse({
      //     ReturnStatement(returnPath) {
      //       if (
      //         returnPath.node.argument &&
      //         returnPath.node.argument.type === "JSXElement"
      //       ) {
      //         ReactComponent = true;
      //       }
      //     },
      //   });
      //   if (ReactComponent) {
      //     reactComponentsPath.add(path);
      //     reactComponentsList.push(path.node.id.name);
      //   }
    },
    ArrowFunctionExpression(path) {
      const parentNode = path.findParent((path) =>
        path.isVariableDeclaration()
      );
      if (parentNode) {
        // parent name
        // console.log(
        //   "ArrowFunctionExpression :" + parentNode.node.declarations[0].id.name
        // );
        if (isReturningJSX(path)) {
          reactComponentsPath.add(path);
          reactComponentsList.push(parentNode.node.declarations[0].id.name);
        }
      }
    },
    CallExpression(path) {
      //   if (path.node.callee && path.node.callee.name === "useState") {
      //     const parentNode = path.findParent((path) =>
      //       path.isVariableDeclaration()
      //     );
      //     if (parentNode) {
      //       // parent name
      //       // console.log(parentNode.node.declarations[0].id.elements[0].name);
      //       useState.add(parentNode.node.declarations[0].id.elements[0].name);
      //     }
      //   }
    },
    exit(path) {
      // console.log(path.node.type);
    },
  });
};
const traverseFunction = (path) => {
  let CC = 0;
  path.traverse({
    IfStatement(path) {
      CC++;
    },
    ConditionalExpression(path) {
      CC++;
    },
    LogicalExpression(path) {
      CC++;
    },
    SwitchStatement(path) {
      CC++;
    },
    ForStatement(path) {
      CC++;
    },
    ForInStatement(path) {
      CC++;
    },
    ForOfStatement(path) {
      CC++;
    },
    WhileStatement(path) {
      CC++;
    },
    DoWhileStatement(path) {
      CC++;
    },
  });
  return CC + 1;
};
const traverseComponent = (path) => {
  const parentNode = path.findParent((path) => path.isVariableDeclaration());
  let name = "";
  if (path.node.id && path.node.id.name) {
    name = path.node.id.name;
  } else if (parentNode) {
    name = parentNode.node.declarations[0].id.name;
  } else {
    name = "Anonymous";
  }
  const props = getComponentsProps(path);
  let functionCount = 0;
  const useStateHooks = new Set();
  const functions = [];
  const useContextHooks = {};
  const numberOfStateTypes = new Set();
  const children = [];
  path.traverse({
    FunctionDeclaration(path) {
      functionCount++;
      const functionObj = {
        name: path.node.id.name,
        loc: getComponentsLOC(path),
        CC: 0,
      };
      functions.push(functionObj);
    },
    ArrowFunctionExpression(path) {
      functionCount++;
      const parentNode = path.findParent((path) =>
        path.isVariableDeclaration()
      );
      let CC = traverseFunction(path);
      if (parentNode) {
        const functionObj = {
          name: parentNode.node.declarations[0].id.name,
          loc: getComponentsLOC(path),
          CC: CC,
        };
        functions.push(functionObj);
      }
    },
    VariableDeclaration(path) {
      if (
        path.node.declarations.some(
          (decl) => decl.init && decl.init.type === "ArrowFunctionExpression"
        )
      ) {
        functionCount++;
      }
    },
    JSXElement(path) {
      const openingElement = path.node.openingElement;
      const jsxName = openingElement.name.name;
      if (reactComponentsList.includes(jsxName)) {
        children.push(jsxName);
      }
    },
    CallExpression(path) {
      if (/^use[A-Z].*Context$/.test(path.node.callee.name)) {
        // console.log(path.node.callee.name);
        const parentPath = path.findParent((path) =>
          path.isVariableDeclaration()
        );
        if (
          parentPath &&
          parentPath.node.declarations[0].id &&
          parentPath.node.declarations[0].id.type === "ObjectPattern"
        ) {
          const properties = parentPath.node.declarations[0].id.properties
            .filter((prop) => !prop.key.name.includes("set"))
            .map((prop) => prop.key.name);

          //   console.log(properties);
          useContextHooks[path.node.callee.name] = properties;
        }
      }
      if (path.node.callee.type && path.node.callee.name === "useState") {
        const parentNode = path.findParent((path) =>
          path.isVariableDeclaration()
        );
        let type = "";
        const initialState = path.node.arguments[0];
        numberOfStateTypes.add(initialState.type);
        if (
          initialState.type === "ArrayExpression" ||
          initialState.type === "ObjectExpression" ||
          initialState.type === "NullLiteral" ||
          initialState.type === "FunctionExpression" ||
          initialState.type === "ArrowFunctionExpression"
        ) {
          type = "Complex";
        } else {
          type = "Primitive";
        }
        if (parentNode) {
          useStateHooks.add({
            type: type,
            name: parentNode.node.declarations[0].id.elements[0].name,
          });
          //   console.log(parentNode.node.declarations[0].id.elements[0].name);
          //   useState.add(parentNode.node.declarations[0].id.elements[0].name);
        }
      }
    },
  });
  reactComponents.push({
    name: name,
    loc: getComponentsLOC(path),
    functionCount: functionCount,
    useContextHooks: useContextHooks,
    useStateHooks: Array.from(useStateHooks),
    numberOfStateTypes: numberOfStateTypes.size,
    props: props,
    children: children,
    functions: functions,
  });
};
async function main() {
  // traverseFile(ast);
  await traverseAll();
  reactComponentsPath.forEach((path) => {
    traverseComponent(path);
  });
  console.log(lineTotal.size);
  console.log(reactComponentsList);
  console.log(reactComponentsList.length);
  //   console.log(lineTotal.size);
  //   console.log(reactComponentsPath.size);
  //   console.log(reactComponents);
  //   console.log(useState);
  // console.log(lineTotal.size);
  // console.log(nodeTypes);
  // console.log(reactComponentsPath);

  const resultJSON = JSON.stringify(reactComponents, null, 2);
  fs.writeFileSync("./result.json", resultJSON);
}
main();
